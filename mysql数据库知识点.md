**mysql数据库知识点：**

1.慢sql语句是因为没有使用索引，所以执行速度慢很多。



2.**索引**是帮助MYSQL高效获取数据的**排好序**的**数据结构**。

索引数据结构：

- 二叉搜索树（不过碰上升序数据查询就会很慢）

- 红黑树，会自旋以降低树的高度（不过数据过大会导致高度不可控）

- 哈希表（基本上不用）

  - 对索引的key进行一次hash计算就可以定义出数据存储位置
  - 很多时候hash索引要比B+树索引更高效
  - 仅能满足“=”，“IN”，**不支持范围查询**，所以基本上不用
  - hash冲突问题

- B+树（InnoDB和MyISAM都在用）如下图：![](C:\Users\x'p\Desktop\工作资料\mysql\B+树例子.png)

  

3.B+树

- 非叶子节点不存储data，只存储索引（冗余），可以放更多的索引

- 叶子节点包含所有的索引

- 叶子节点用指针连接，提高区间访问的性能

  **叶子节点放在磁盘，冗余的索引则放在内存**

  B树与B+树的根本区别

  

4.**MyISAM存储引擎**

索引文件（.MYI文件）和数据文件（.MYD文件）是分离的（非聚集，稀疏）（.frm文件存储的是表结构）

![](C:\Users\x'p\Desktop\工作资料\mysql\MyISAM存储引擎示例.png)



5.**InnoDB存储引擎**

索引（聚集索引，聚簇索引）实现：

- 表数据文件本身就是按B+树组织的一个索引结构文件

- 聚集索引-叶节点包含了完整的数据记录

- 必须建主键，推荐使用**整型**的**自增**型主键

  **整型**：UUID是字符串，比起整型做比较麻烦，性能不好而且存储空间还大， 故尽量不用UUID做主键

  **自增**：因为B+树是会把索引排序的，自增的主键会一直往后面添加，而非自增的插入在叶子节点时可能会发生分裂，从而导致性能下降，而自增的发生概率就很小

- 非主键索引结构叶子节点存储的是主键值（一致性和节省存储空间）

  ![  ](C:\Users\x'p\Desktop\工作资料\mysql\InnoDB存储引擎示例.png)
  
  

6.**联合索引**（多个字段）索引最左前缀原则

例：KEY 'idx_name_age_position' ('name', 'age', 'position') USING BTREE

SELECT * FROM employee WHERE name = 'BILL' and age = 31;(使用了联合索引)

SELECT * FROM employee WHERE age = 30 AND position = 'dev';

SELECT * FROM employee WHERE position = 'manager';

![](C:\Users\x'p\Desktop\工作资料\mysql\联合索引示例.png)

一般叶子节点除了索引就存储了主键，查找数据是先根据索引找到对应的叶子节点，再根据里面放的主键去查找以主键为索引的表，该操作称为回表。

联合索引不一定支持范围查找，如果是selelct*就不行，因为回表次数过多可能没全表扫描快。

7.**buffer pool**缓存池存储结构（MySQL取数据的最小单位是页，InnoDB是16KB）

数据库的crud都是直接操作buffer pool，一般设置为机器内存的60%左右  

**free链表**管理buffer pool里面空闲的页，有个基节点存放：多少个空闲页，头结点，尾节点来控制

**flush链表**管理buffer pool里面的脏页，有个基节点存放：多少个脏页，头结点，尾节点来控制

（后台线程会定时扫描flush链表去把脏页持久化到磁盘）

**lru链表**（最近最少使用链表）最新操作的页放在头结点，每次新来的页就把链表尾部的页删除，把新页放在头结点（缺点：大表的全表扫描可能会把热数据给替换掉了）

**升级版lru链表**：（1）分区域，5/8为热数据区域，3/8为冷数据区域，新加数据放入冷数据区域

何时把冷数据转为热数据呢？

当某一个冷数据第二次访问时间t2-t1 > 1s时，放入热数据表头区域。

为什么是>呢？

防止全表扫描的情况发生，全表扫描必然不满足以上条件，因为一直在同一页上扫描，速度极快



8.**Redo Log**日志（在磁盘里面）和 **Log Buffe**r（在内存里）

update语句步骤：

1.更新buffer pool里面页里面的数据

2.生成一个redolog对象（记录了这条sql语句）保存到**Log Buffe**r里面

3.生成一个binlog对象

4.生成一个undolog对象

5.事务commit后再持久化这个redolog对象到**Redo Log**里面（顺序io，在连续空间内顺序寻址）两个默认连续空间log文件保存redolog对象

为什么不直接持久化这个页而是持久化redolog对象呢？

（1）如果只更新某几行数据就要把整页持久化过去，浪费资源；

（2）如果更新了多行，但如果采用的是**随机io**会导致寻址（跳跃）的时候太费时间



9.**binlog** 和 **undolog**

binlog也是记录更新的sql语句， 但与redolog不同的是，redolog是属于InnoDB索引的，而binlog是属于MySQL数据库的

undolog记录了之前的sql语句



10.**Doublewrite buffer** （磁盘内）（数据库一页默认16k而操作系统为4k）

脏页写写入双写缓冲区，写入成功后删除redo log，否则不删除

然后再写入表空间



11.**change buffer**（内存和磁盘都有）优化写操作如 insert update

update语句修改时不仅要把数据页放入buffer pool，还要把多个相关的索引页也放进去，这样就会产生多个io事件，而change buffer作用就是在update时不把索引放入buffer pool，而是把这条语句放入change buffer，等再次查询这个已被修改的数据时，发现change buffer里有这个数据被修改的记录，此时会把索引页放入buffer pool并修改

12.MySQL复制（DDL 、DML有关）

原理：在数据commit后，主库会把数据的变化写到binlog里面，然后里面有个线程会发送binlog给从库

从库中有一个线程专门接受binlog并写入relay log里面，然后另一个线程读取该log文件把变化写入表中

缺点：延迟

优点：避免单点故障；读写分离，均衡数据库负载